/*
 * Assignatura 21742 - Compiladors
 * Estudis: Grau en Informàtica
 * Itinerari: Computació
 * Curs: 2022 - 2023
 */

package compiler.sintactic;

import java_cup.runtime.*;
import compiler.sintactic.Symbols.*;
import compiler.sintactic.*;
import compiler.sintactic.Symbol;
import compiler.ErrorC;
import java.util.List;

class Parser;
parser code {:
/***
    private Scanner scanner;
    public Parser(Scanner scanner) {
        this.scanner = scanner;
    }
***/
    TSimbolos tSimbolos = new TSimbolos();
    AnSem ansem = new AnSem(tSimbolos);

    public TSimbolos getTSimbolos() {
        return tSimbolos;
    }


    @Override
    public void syntax_error(java_cup.runtime.Symbol cur_token) {
        String message = "Obtuvimos " + cur_token.toString().split(" ")[1] + " y esperabamos " + this.showExpectedTokenIds();
        ComplexSymbolFactory.ComplexSymbol cs = (ComplexSymbolFactory.ComplexSymbol) cur_token;
        ErrorC.añadirError(new ErrorC(message, cs.getLeft().getLine(), Fase.SINTÁCTICO));
    }

    private String showExpectedTokenIds() {
        List<String> list = this.expected_token_ids().stream().map(this::symbl_name_from_id).toList();
        return (list.size() > 0) ? list.toString() : "something else";
    }

    private int getDimensionesArray(List_arr list_arr) {
        int dimensiones = 0;
        for (List_arr aux = list_arr; aux != null; aux = aux.getList_arr()) {
            dimensiones++;
        }
        return dimensiones;
    }
:}

terminal        SI, SINO, SINOSI, PARA, MIENTRAS, HACER, ROMPER, ENTERO, BOOLEANO, CONST,
                FUNCION, DEVUELVE, CONTINUAR, IMPRIMIR, LEERENT, LEERCAR, LEERBOOL, PRINCIPAL, SUMA, RESTA,
                MULT, DIV, MOD, Y, O, IGUAL, IGUALNT, MAQ, MEQ, MAI, MEI, ASIG, PAR_A, PAR_C, LLAVE_A,
                LLAVE_C, CORCHETE_A, CORCHETE_C, COMA, COMILLAS, P_COMA, VACIO;

terminal        String          DIGITO;
terminal        String          ID;
terminal        String          VAL_BOL;
terminal        String          CARACTER;

non terminal                    M;
non terminal    Xava            XAVA;
non terminal    DeclGlob        DECLGLOB;
non terminal    Main_fn         MAIN_FN;
non terminal    Funciones       FUNCIONES;
non terminal    FuncionG        FUNCIONG;
non terminal    Cap             CAP;
non terminal    EnumType        ETYPE;
non terminal    EnumType        STYPE;
non terminal    Args_Cap        ARGS_CAP;
non terminal    L_args_Cap      L_ARGS_CAP;
non terminal    Args_Call       ARGS_CALL;
non terminal    L_args_Call     L_ARGS_CALL;
non terminal    FSents          FSENTS;
non terminal    RetProc         RET_PROC;
non terminal    Sents           SENTS;
non terminal    Sent            SENT;
non terminal    DeclsF          DECLSF;
non terminal    DeclF           DECLF;
non terminal    Args_Declf      ARGS_DECLF;
non terminal    L_args_Declf    L_ARGS_DECLF;
non terminal    Decls           DECLS;
non terminal    Decl            DECL;
non terminal    Inst            INST;
non terminal    C_sents         C_SENTS;
non terminal    C_sent          C_SENT;
non terminal    Cont_cond       CONT_COND;
non terminal    Type            TYPE;
non terminal    D_asig          DASIGNACION;
non terminal    Lid             LID;
non terminal    Exp             E;
non terminal    Entrada         ENTRADA;
non terminal    Op              OP;
non terminal    Value           VALUE;
non terminal    ArrayG          ARRAY;
non terminal    L_array         L_ARR;

non terminal    Call_fn         CALL_FN;



start with      XAVA;

XAVA            ::= DECLGLOB:gdecls MAIN_FN:main FUNCIONES:funciones                                {: RESULT = new Xava(gdecls, main, funciones, 0, 0);                            :}
                ;

MAIN_FN         ::= M PRINCIPAL LLAVE_A FSENTS:fsents LLAVE_C                                       {: System.out.println("He analizado el principal");RESULT = new Main_fn(fsents, fsentsleft, fsentsright);                       :}
                ;

DECLGLOB        ::= DECLS:decls DECLSF:declsf
                    {:
                        ComplexSymbolFactory.ComplexSymbol cs = (ComplexSymbolFactory.ComplexSymbol) cur_token;
                        RESULT = new DeclGlob(declsf, decls, cs.getLeft().getLine(), cs.getLeft().getColumn());
                    :}
                ;

DECLSF          ::= DECLF:declf DECLSF:declsf                                                       {: RESULT = new DeclsF(declf, declsf, declfleft, declfright);                   :}
                |                                                                                   {: :}
                ;

DECLF           ::= M FUNCION ETYPE:eType ID:id ARGS_DECLF:args_declf P_COMA
                    {:  if (!tSimbolos.ponerSimbolo(new Symbol(id, TipoElemento.FUNCION, eType, null, true, 0, idleft))) {
                            // MANEJO DE ERRORES SEMANTICOS
                            // O la función ha sido declarada anteriormente o el nombre de la función ya está usada
                            ErrorC.añadirError(new ErrorC("Función " + id + "declarada previamente", idleft, Fase.SEMÁNTICO));
                        }
                        RESULT = new DeclF(eType, id, args_declf, eTypeleft, eTyperight);
                    :}
                ;

ARGS_DECLF      ::= PAR_A L_ARGS_DECLF:args PAR_C
                    {:
                        RESULT = new Args_Declf(args, args.getLinea(), args.getColumna());
                    :}
                |   PAR_A PAR_C
                {:
                    ComplexSymbolFactory.ComplexSymbol cs = (ComplexSymbolFactory.ComplexSymbol) cur_token;
                    RESULT = new Args_Declf(null, cs.getLeft().getLine(), cs.getLeft().getColumn());
                :}
                ;

L_ARGS_DECLF    ::= STYPE:stype ID:id COMA L_ARGS_DECLF:args
                    {:  if (!tSimbolos.ponerSimbolo(new Symbol(id, TipoElemento.PARAMETRO, stype, null, false, 0, idleft))) {
                            // MANEJO DE ERRORES SEMANTICOS
                            // O la variable ha sido declarada anteriormente o el nombre de la variable ya está usada
                            ErrorC.añadirError(new ErrorC("Variable " + id + "declarada previamente", idleft, Fase.SEMÁNTICO));
                        }
                        RESULT = new L_args_Declf(stype, id, args, stypeleft, styperight);
                    :}
                |   STYPE:stype ID:id
                    {:
                        if (!tSimbolos.ponerSimbolo(new Symbol(id, TipoElemento.PARAMETRO, stype, null, false, 0, idleft))) {
                            // MANEJO DE ERRORES SEMANTICOS
                            // O la variable ha sido declarada anteriormente o el nombre de la variable ya está usada
                            ErrorC.añadirError(new ErrorC("Variable " + id + "declarada previamente", idleft, Fase.SEMÁNTICO));
                        }
                        RESULT = new L_args_Declf(stype, id, stypeleft, styperight);
                    :}
                ;

DECLS           ::= DECL:decl DECLS:decls                                                           {: RESULT = new Decls(decl, decls, declleft, declright);                            :}
                |                                                                                   {: :}
                ;

FUNCIONES       ::= FUNCIONG:f FUNCIONES:funciones                                                  {: RESULT = new Funciones(f, funciones, fleft,fright);                              :}
                |                                                                                   {: :}
                ;

FUNCIONG        ::= FUNCION CAP:cap LLAVE_A FSENTS:f_sents LLAVE_C
                    {:
                        if (ansem.existeFuncion(cap)) {
                            ansem.isReturn(f_sents);
                            RESULT = new FuncionG(cap, f_sents, capleft, capright);
                        }
                        System.out.println("He analizado la funcion");

                    :}
                ;

CAP             ::= ETYPE:etype ID:id ARGS_CAP:args_cap
                    {:
                        tSimbolos.updatenActual(id);
                        System.out.println("He analizado el cap"); RESULT = new Cap(etype, id, args_cap, etypeleft, etyperight);
                    :}
                ;

ETYPE           ::= STYPE:stype                                                                     {: RESULT = stype;                                                                  :}
                |   VACIO                                                                           {: RESULT = EnumType.VACIO;                                                        :}
                ;

STYPE           ::= ENTERO                                                                          {: RESULT = EnumType.ENTERO;                                                       :}
                |   BOOLEANO                                                                        {: RESULT = EnumType.BOOLEANO;                                                     :}
                |   CARACTER                                                                        {: RESULT = EnumType.CARACTER;                                                     :}
                ;

ARGS_CAP        ::= PAR_A L_ARGS_CAP:args PAR_C                                                     {: RESULT = new Args_Cap(args, args.getLinea(), args.getColumna());                            :}
                |   PAR_A PAR_C
                {:
                    ComplexSymbolFactory.ComplexSymbol cs = (ComplexSymbolFactory.ComplexSymbol) cur_token;
                    RESULT = new Args_Cap(null, cs.getLeft().getLine(), cs.getLeft().getColumn());
                :}
                ;

ARGS_CALL       ::= PAR_A L_ARGS_CALL:l_args_call PAR_C                                             {: RESULT = new Args_Call(l_args_call, l_args_call.getLinea(), l_args_call.getColumna());      :}
                |   PAR_A PAR_C
                {:
                    ComplexSymbolFactory.ComplexSymbol cs = (ComplexSymbolFactory.ComplexSymbol) cur_token;
                    RESULT = new Args_Call(null, cs.getLeft().getLine(), cs.getLeft().getColumn());
                :}
                ;

L_ARGS_CAP      ::= STYPE:stype ID:id COMA L_ARGS_CAP:l_args_cap                                    {: RESULT = new L_args_Cap(stype, id, l_args_cap, stypeleft, styperight);       :}
                |   STYPE:stype ID:id                                                               {: RESULT = new L_args_Cap(stype, id, stypeleft, styperight);                   :}
                ;

L_ARGS_CALL     ::= VALUE:value                                                                     {: RESULT = new L_args_Call(value, valueleft, valueright);                               :}
                |   VALUE:value COMA L_ARGS_CALL:l_args_call                                        {: RESULT = new L_args_Call(value, l_args_call, valueleft, valueright);                  :}
                ;

FSENTS          ::= SENTS:sents RET_PROC:ret_proc                                                   {: System.out.println("He analizado el fsents");RESULT = new FSents(sents, ret_proc, sentsleft, sentsright);                 :}
                |   SENTS:sents                                                                     {: System.out.println("He analizado el fsents");RESULT = new FSents(sents, sentsleft, sentsright);                           :}
                ;

RET_PROC        ::= DEVUELVE E:exp P_COMA                                                           {: RESULT = new RetProc(exp, expleft, expright);                                :}
                ;

SENTS           ::= SENT:sent SENTS:sents                                                           {: RESULT = new Sents(sent, sents, sentleft, sentright);                        :}
                |                                                                                   {: :}
                ;

SENT            ::= DECL:decl                                                                       {: RESULT = new Sent(decl, declleft, declright);                                :}
                |   INST:inst                                                                       {: RESULT = new Sent(inst, instleft, instright);                                :}
                ;

DECL            ::= TYPE:type LID:lid DASIGNACION:d_asignacion P_COMA
                    {:
                        ansem.gestAsig(type.getStype(), d_asignacion.getE());
                        for (Lid aux = lid; aux != null; aux = aux.getLid()) {
                            if (!tSimbolos.ponerSimbolo(new Symbol(aux.getId(), TipoElemento.VARIABLE, type.getStype(), null, type.getConstante(), 0, lidleft))) {
                                // MANEJO DE ERRORES SEMANTICOS
                                // O la variable ha sido declarada anteriormente o el nombre de la variable ya está usada
                                ErrorC.añadirError(new ErrorC("Variable declarada previamente", aux.getLinea(), Fase.SEMÁNTICO));
                            }
                        }

                        RESULT = new Decl(type, lid, d_asignacion, typeleft, typeright);
                    :}
                |   TYPE:type ARRAY:array ID:id P_COMA
                    {:
                        if (!type.getConstante()) {

                            if (!tSimbolos.ponerSimbolo(new Symbol(id, TipoElemento.ARRAY, type.getStype(), null, false, array.getDimension(), idleft))) {
                                // MANEJO DE ERRORES SEMANTICOS
                                // O la variable ha sido declarada anteriormente o el nombre de la variable ya está usada
                                ErrorC.añadirError(new ErrorC("Variable " + id + "declarada previamente", idleft, Fase.SEMÁNTICO));
                            }
                            RESULT = new Decl(type, id, array, typeleft, typeright);
                        } else {
                            // MANEJO DE ERRORES SEMANTICOS
                            // No se puede declarar un array de tipo constante
                            ErrorC.añadirError(new ErrorC("Un array no puede ser constante", idleft, Fase.SEMÁNTICO));
                        }
                    :}
                ;

INST            ::= SI PAR_A E:exp PAR_C LLAVE_A C_SENTS:c_sents LLAVE_C CONT_COND:cont_cond
                    {:
                        RESULT = new Inst("cond", exp, c_sents, null, null, cont_cond, expleft, expright);
                    :}

                |   PARA PAR_A DECL:decl_cap P_COMA E:exp P_COMA DECL:decl PAR_C LLAVE_A C_SENTS:c_sents LLAVE_C
                    {:
                        RESULT = new Inst("para", exp, c_sents, decl_cap, decl, null, decl_capleft, decl_capright);
                    :}

                |   MIENTRAS PAR_A E:exp PAR_C LLAVE_A C_SENTS:c_sents LLAVE_C                      {: RESULT = new Inst("mientras", exp, c_sents, null, null, null, expleft, expright);     :}
                |   HACER LLAVE_A C_SENTS:c_sents LLAVE_C MIENTRAS PAR_A E:exp PAR_C P_COMA
                    {:
                        RESULT = new Inst("hacer_mientras", exp, c_sents, null, null, null, c_sentsleft, c_sentsright);
                    :}

                |   ID:id ASIG E:exp P_COMA
                    {:
                        Symbol symbol = tSimbolos.getSymbol(id);
                        ansem.gestAsig(symbol.getTipoReturn(), exp);
                        RESULT = new Inst("asig", id, null, exp, idleft, idright);
                    :}
                |   ID:id CORCHETE_A E:expArr CORCHETE_C ASIG E:exp P_COMA
                    {:
                        if (ansem.gestExp(expArr) != EnumType.ENTERO) {
                            // MANEJO DE ERRORES SEMANTICOS
                            // El índice del array debe ser de tipo entero
                            ErrorC.añadirError(new ErrorC("El indice del array debe ser de tipo entero", expArr.getLinea(), Fase.SEMÁNTICO));
                        }
                        Symbol symbol = tSimbolos.getSymbol(id);
                        ansem.gestAsig(symbol.getTipoReturn(), exp);
                        RESULT = new Inst("asig", id, expArr, exp, idleft, idright);
                    :}
                |   IMPRIMIR PAR_A E:exp PAR_C P_COMA                                               {: RESULT = new Inst("impr", null, null, exp, expleft, expright);                     :}
                ;

C_SENTS         ::= SENT:sent C_SENTS:c_sents                                                       {: RESULT = new C_sents(sent, c_sents, sentleft, sentright);                    :}
                |   C_SENT:c_sent C_SENTS: c_sents                                                  {: RESULT = new C_sents(c_sent, c_sents, c_sentleft, c_sentright);              :}
                |                                                                                   {: :}
                ;

C_SENT          ::= ROMPER P_COMA
                    {:
                        ComplexSymbolFactory.ComplexSymbol cs = (ComplexSymbolFactory.ComplexSymbol) cur_token;
                        RESULT = new C_sent("Romper", null, cs.getLeft().getLine(), cs.getLeft().getColumn());
                    :}
                |   CONTINUAR P_COMA
                    {:
                        ComplexSymbolFactory.ComplexSymbol cs = (ComplexSymbolFactory.ComplexSymbol) cur_token;
                        RESULT = new C_sent("Continuar", null, cs.getLeft().getLine(), cs.getLeft().getColumn());
                    :}
                |   RET_PROC:ret_proc
                    {: ansem.gestReturnFunc(ret_proc);
                       RESULT = new C_sent("ret_proc", ret_proc, ret_procleft, ret_procright);
                    :}
                ;

CONT_COND       ::= SINO LLAVE_A SENTS:sents LLAVE_C                                                {: RESULT = new Cont_cond(null, sents, null, sentsleft, sentsright);            :}
                |   SINOSI PAR_A E:exp PAR_C LLAVE_A SENTS:sents LLAVE_C CONT_COND:cont_cond
                    {:
                        RESULT = new Cont_cond(exp, sents, cont_cond, expleft, expright);
                    :}
                |                                                                                   {: :}
                ;

TYPE            ::= STYPE:stype
                    {:
                        ComplexSymbolFactory.ComplexSymbol cs = (ComplexSymbolFactory.ComplexSymbol) cur_token;
                        RESULT = new Type(false, stype, cs.getLeft().getLine(), cs.getLeft().getColumn());
                    :}
                |   CONST STYPE:stype
                    {:
                        ComplexSymbolFactory.ComplexSymbol cs = (ComplexSymbolFactory.ComplexSymbol) cur_token;
                        RESULT = new Type(true, stype, cs.getLeft().getLine(), cs.getLeft().getColumn());
                    :}
                ;

DASIGNACION     ::= ASIG E:exp                                                                      {: RESULT = new D_asig(exp, expleft, expright);                                 :}
                |                                                                                   {: :}
                ;

LID             ::= ID:id COMA LID:lid                                                              {: RESULT = new Lid(id, lid, idleft, idright);                                  :}
                |   ID:id                                                                           {: RESULT = new Lid(id, idleft, idright);                                       :}
                ;

ENTRADA         ::= LEERBOOL
                    {:
                        ComplexSymbolFactory.ComplexSymbol cs = (ComplexSymbolFactory.ComplexSymbol) cur_token;
                        RESULT = new Entrada(EnumType.BOOLEANO, cs.getLeft().getLine(), cs.getLeft().getColumn());
                    :}
                |   LEERCAR
                    {:
                        ComplexSymbolFactory.ComplexSymbol cs = (ComplexSymbolFactory.ComplexSymbol) cur_token;
                        RESULT = new Entrada(EnumType.CARACTER, cs.getLeft().getLine(), cs.getLeft().getColumn());
                    :}
                |   LEERENT
                {:
                    ComplexSymbolFactory.ComplexSymbol cs = (ComplexSymbolFactory.ComplexSymbol) cur_token;
                    RESULT = new Entrada(EnumType.ENTERO, cs.getLeft().getLine(), cs.getLeft().getColumn());
                :}
                ;

E               ::= VALUE:value OP:op E:exp                                                         {: System.out.println("Expresion con op");RESULT = new Exp(value, op, exp, valueleft, valueright);                      :}
                |   VALUE:value                                                                     {: System.out.println("Expresion sin op");RESULT = new Exp(value, valueleft, valueright);                               :}
                ;

OP              ::= Y                                                                               {: RESULT = Op.Y;                                                               :}
                |   O                                                                               {: RESULT = Op.O;                                                               :}
                |   IGUAL                                                                           {: RESULT = Op.IGUAL;                                                           :}
                |   IGUALNT                                                                         {: RESULT = Op.IGUALNT;                                                         :}
                |   MAQ                                                                             {: RESULT = Op.MAQ;                                                             :}
                |   MEQ                                                                             {: RESULT = Op.MEQ;                                                             :}
                |   MAI                                                                             {: RESULT = Op.MAI;                                                             :}
                |   MEI                                                                             {: RESULT = Op.MEI;                                                             :}
                |   SUMA                                                                            {: RESULT = Op.SUMA;                                                            :}
                |   RESTA                                                                           {: RESULT = Op.RESTA;                                                           :}
                |   MULT                                                                            {: RESULT = Op.MULT;                                                            :}
                |   DIV                                                                             {: RESULT = Op.DIV;                                                             :}
                |   MOD                                                                             {: RESULT = Op.MOD;                                                             :}
                ;

VALUE           ::= DIGITO:num                                                                      {: RESULT = new Value(num, "Ent", numleft, numright);                                  :}
                |   CALL_FN:call_fn                                                                 {: RESULT = new Value(call_fn, call_fnleft, call_fnright);                      :}
                |   ID:id                                                                           {: RESULT = new Value(id, "Id", idleft, idright);                               :}
                |   ARRAY:array
                {:
                    RESULT = new Value(array, "Arr", arrayleft, arrayright);
                :}
                |   COMILLAS CARACTER:car COMILLAS                                                  {: RESULT = new Value(car, "Car", carleft, carright);                      :}
                |   VAL_BOL:val_bol                                                                 {: RESULT = new Value(val_bol, "Bol", val_bolleft, val_bolright);          :}
                |   PAR_A E:exp PAR_C                                                               {: RESULT = new Value(exp, expleft, expright);                                  :}
                |   ENTRADA:entrada                                                                 {: RESULT = new Value(entrada, entradaleft, entradaright);                      :}
                ;

ARRAY           ::= ID:id L_ARR:list_arr
                {:
                    nDimensiones = getDimensionesArray(list_arr);
                    ansem.gestArray(id, nDimensiones, list_arrleft);
                    RESULT = new ArrayG(id, list_arr, nDimensiones, idleft, idright);
                :}
                ;

L_ARR        ::= CORCHETE_A E:expArr CORCHETE_C LIST_ARR:list_array
                {:
                    if (ansem.gestExp(expArr) != EnumType.ENTERO) {
                        // MANEJO DE ERRORES SEMANTICOS
                        // El índice del array debe ser de tipo entero
                        ErrorC.añadirError(new ErrorC("El indice del array debe ser de tipo entero", expArr.getLinea(), Fase.SEMÁNTICO));
                    }
                    RESULT = new List_arr(expArr, list_array, expArrleft, expArrright);
                :}
                |                                                                                   {: :}
                ;

CALL_FN         ::= ID:id ARGS_CALL:args_call                                                       {: RESULT = new Call_fn(id, args_call, args_callleft, args_callright);          :}
                ;

M               ::=                                                                                 {: tSimbolos.añadirAmbito();                                                    :}
                ;
